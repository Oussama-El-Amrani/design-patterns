# Design Patterns UML Class Diagrams



## Adapter Pattern

Allows incompatible interfaces to work together. It wraps an existing class with a new interface.


![Adapter Pattern](docs/images/Adapter.png)

## Composite Pattern

Composes objects into tree structures to represent part-whole hierarchies. It allows clients to treat individual objects and compositions of objects uniformly.


![Composite Pattern](docs/images/Composite.png)

## Decorator Pattern

Attaches additional responsibilities to an object dynamically. It provides a flexible alternative to subclassing for extending functionality.


![Decorator Pattern](docs/images/Decorator.png)

## Observer Pattern

Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.


![Observer Pattern](docs/images/observer.png)

## Proxy Pattern

Provides a surrogate or placeholder for another object to control access to it.


![Proxy Pattern](docs/images/Proxy.png)

## State Pattern

Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.


![State Pattern](docs/images/State.png)

## Strategy Pattern

Defines a family of algorithms, encapsulates each one, and makes them interchangeable. It allows the algorithm to vary independently from clients that use it.


![Strategy Pattern](docs/images/Strategy.png)

## Template Pattern

Defines the skeleton of an algorithm in an operation, deferring some steps to subclasses. It allows subclasses to redefine certain steps of an algorithm without changing the algorithm's structure.


![Template Pattern](docs/images/Template.png)
